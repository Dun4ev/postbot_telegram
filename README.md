# Telegram Post Queue Bot

## Обзор
Этот репозиторий содержит Telegram-бота, который принимает сообщения в личных сообщениях и публикует их в канале по расписанию. Очередь хранится в SQLite, обработка сообщений выполняется через `python-telegram-bot` в режиме long-polling. Проект реализует идею: кидаете текст или фото в ЛС боту → элемент попадает в FIFO-очередь (`queue.db`) → бот публикует пост ровно 5 раз в день по слотам в `Europe/Belgrade`. Цель — минимальный когнитивный шум и развёртывание на macOS, затем на Synology (Docker).

## Требования
- Python 3.11+
- Активированный ботовый токен Telegram
- Доступ к каналу (бот должен быть администратором)
- Docker (опционально) для контейнерного деплоя

## Быстрый старт
```bash
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
# создайте файл .env и заполните переменные окружения
python bot.py
```

## Конфигурация
Создайте файл `.env` в корне проекта и задайте переменные окружения:
- `TG_BOT_TOKEN` — токен бота (обязательно).
- `TG_CHANNEL` или `TG_CHANNEL_ID` — целевой канал.
- `TZ` — часовой пояс (по умолчанию `Europe/Belgrade`).
- `POST_SLOTS` — список времён публикации (формат `HH:MM,HH:MM`).
Очередь хранится в `queue.db` в корне проекта.

## Работа очереди
1. Пользователь отправляет текст или фото боту в DM.
2. Сообщение попадает в FIFO-очередь.
3. По расписанию слот запускает `publish_next` и пост уходит в канал.
Состояние очереди можно посмотреть командой `/queue`, очистка — `/purge`.

## Запуск через Docker Compose
```bash
docker-compose up --build
```
Файл `docker-compose.yml` устанавливает зависимости и монтирует каталог `/volume1/tgqueue` в контейнер.

## Разработка и проверки
Перед коммитом прогоните:
```bash
ruff check .
black --check .
mypy .
pytest -q
```
Тесты рекомендуется складывать в `tests/` с зеркальной структурой относительно кода. Для интеграционных сценариев используйте заглушки Telegram API.

## Рекомендации по эксплуатации
- **Лимиты Telegram** — бот должен быть администратором канала; при ошибках прав или Flood Control мониторьте вывод `bot.py`, элементы очереди не потеряются, но будут откладываться.
- **Очередь** — периодически проверяйте размер `queue.db` (`sqlite3 queue.db 'select count(*) from queue;'`); при необходимости используйте команду `/purge` и выполняйте повторную постановку.
- **Расписание** — задавайте `TZ` и `POST_SLOTS` только валидными значениями (`Europe/Moscow`, `HH:MM`); для быстрой отладки удобно указывать ближайший слот через `export POST_SLOTS="$(date -v+5M +%H:%M)"`.
- **Мониторинг** — включите логирование stdout в файл (например, `python bot.py >> bot.log 2>&1`) и настройте уведомления при повторяющихся `Publish error`.
- **Резервное копирование** — храните бэкап `queue.db` и `.env` (без токенов в открытом виде) если очередь критична.
